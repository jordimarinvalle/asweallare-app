<div class="page no-navbar no-toolbar" data-name="game">
  <div class="page-content" style="padding: 0;">
    
    <!-- Rotate Device Screen -->
    <div id="rotate-screen" class="rotate-device-screen" style="display: none;">
      <div class="rotate-icon">
        <i class="f7-icons" style="font-size: 64px; color: #8E8E93;">device_phone_landscape</i>
      </div>
      <h2 style="margin-top: 24px; font-size: 20px; font-weight: 600;">Rotate Your Device</h2>
      <p style="color: #8E8E93; margin-top: 8px;">Please rotate to landscape mode to play</p>
    </div>
    
    <!-- Game Content -->
    <div id="game-content" class="game-content game-screen" style="display: flex;">
      
      <!-- Exit Button -->
      <button id="exit-btn" class="button" style="position: absolute; top: 20px; left: 20px; padding: 8px 16px; z-index: 100;">
        <i class="f7-icons" style="font-size: 20px;">xmark</i>
      </button>
      
      <!-- Timer Display -->
      <div id="timer-display" class="timer-display idle">
        Tap on the cards to flip them and start your turn
      </div>
      
      <!-- Reset Button -->
      <button id="reset-btn" class="button" style="position: absolute; top: 20px; right: 20px; padding: 8px; z-index: 100;">
        <i class="f7-icons" style="font-size: 20px;">arrow_counterclockwise</i>
      </button>
      
      <!-- Card Piles Container -->
      <div id="piles-container" class="game-cards-container">
        
        <!-- Black Pile -->
        <div id="black-pile-container" class="pile-container" style="text-align: center; transition: all 0.3s ease;">
          <div id="black-stack" class="card-stack" style="position: relative; width: 252px; height: 352px;">
            <!-- Stack will be rendered by JS -->
          </div>
          <p id="black-count" class="pile-count" style="margin-top: 12px; color: #8E8E93; font-size: 14px;">Loading...</p>
        </div>
        
        <!-- White Pile -->
        <div id="white-pile-container" class="pile-container" style="text-align: center; transition: all 0.3s ease;">
          <div id="white-stack" class="card-stack" style="position: relative; width: 252px; height: 352px;">
            <!-- Stack will be rendered by JS -->
          </div>
          <p id="white-count" class="pile-count" style="margin-top: 12px; color: #8E8E93; font-size: 14px;">Loading...</p>
        </div>
        
      </div>
      
    </div>
  </div>
</div>

<script>
(function() {
  const state = window.appState;
  const { drawCard, flipCard, resetRound, endGame, startSharing, finishSharing } = window.appFunctions;
  
  const MAX_VISIBLE_STACK = 5;
  
  // Generate random rotation between -4 and 4 degrees (no offset)
  function getRandomRotation() {
    return (Math.random() - 0.5) * 8;
  }
  
  // Helper to get correct image URL
  function getImageUrl(path) {
    if (!path) return '';
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }
    return path.startsWith('/') ? path : '/' + path;
  }
  
  // Update pile visibility - hide empty pile and center the active one
  function updatePileVisibility() {
    const blackContainer = document.getElementById('black-pile-container');
    const whiteContainer = document.getElementById('white-pile-container');
    const pilesContainer = document.getElementById('piles-container');
    
    const blackCount = state.blackDeck ? state.blackDeck.length : 0;
    const whiteCount = state.whiteDeck ? state.whiteDeck.length : 0;
    const hasCurrentBlack = state.currentBlack !== null;
    const hasCurrentWhite = state.currentWhite !== null;
    
    // Determine if each pile should be visible
    const showBlack = blackCount > 0 || hasCurrentBlack;
    const showWhite = whiteCount > 0 || hasCurrentWhite;
    
    if (blackContainer) {
      blackContainer.style.display = showBlack ? 'block' : 'none';
    }
    if (whiteContainer) {
      whiteContainer.style.display = showWhite ? 'block' : 'none';
    }
    
    // Center the remaining pile if only one is visible
    if (pilesContainer) {
      if (showBlack && !showWhite) {
        pilesContainer.style.justifyContent = 'center';
      } else if (!showBlack && showWhite) {
        pilesContainer.style.justifyContent = 'center';
      } else {
        pilesContainer.style.justifyContent = 'center';
      }
    }
  }
  
  // Render the card stack with visual cards using pile images
  function renderStack(pile) {
    const stackEl = document.getElementById(`${pile}-stack`);
    if (!stackEl) return;
    
    const deck = pile === 'black' ? state.blackDeck : state.whiteDeck;
    const currentCard = pile === 'black' ? state.currentBlack : state.currentWhite;
    const isFlipped = pile === 'black' ? state.blackFlipped : state.whiteFlipped;
    const deckCount = deck ? deck.length : 0;
    
    // Get pile image from state (fetched from card data)
    const pileImage = pile === 'black' ? state.blackPileImage : state.whitePileImage;
    const fallbackBg = pile === 'black' ? '#000' : '#fff';
    const borderColor = pile === 'black' ? '#444' : '#ddd';
    
    // Clear existing
    stackEl.innerHTML = '';
    
    // Calculate how many stack cards to show (max 5, but not more than deck has)
    const stackCount = Math.min(MAX_VISIBLE_STACK, deckCount);
    
    // Create stack cards (bottom to top) - only rotation, no offset
    for (let i = 0; i < stackCount; i++) {
      const rotation = getRandomRotation();
      const zIndex = i + 1;
      
      const stackCard = document.createElement('div');
      stackCard.className = 'stack-card';
      stackCard.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 252px;
        height: 352px;
        border-radius: 12px;
        overflow: hidden;
        background: ${fallbackBg};
        border: 2px solid ${borderColor};
        transform: rotate(${rotation}deg);
        z-index: ${zIndex};
        pointer-events: none;
      `;
      
      if (pileImage) {
        stackCard.innerHTML = `<img src="${getImageUrl(pileImage)}" alt="" style="width:100%;height:100%;object-fit:cover;border-radius:10px;" onerror="this.style.display='none'" />`;
      }
      
      stackEl.appendChild(stackCard);
    }
    
    // Create the top interactive card if there are cards or a current card
    if (currentCard || deckCount > 0) {
      const topCard = document.createElement('div');
      topCard.className = 'top-card';
      topCard.id = `${pile}-top-card`;
      topCard.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 252px;
        height: 352px;
        border-radius: 12px;
        overflow: hidden;
        background: ${fallbackBg};
        border: 2px solid ${borderColor};
        z-index: 20;
        cursor: pointer;
      `;
      
      if (currentCard && isFlipped) {
        // Show the front of the current card (revealed)
        const imgSrc = getImageUrl(currentCard.image_path || currentCard.imagePath);
        topCard.innerHTML = imgSrc 
          ? `<img src="${imgSrc}" alt="Card" style="width:100%;height:100%;object-fit:cover;border-radius:10px;" onerror="this.style.display='none'" />`
          : `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:#888;">No Image</div>`;
      } else {
        // Show the back of the card (pile image) with "Tap" indicator
        const backImg = pileImage ? `<img src="${getImageUrl(pileImage)}" alt="${pile} card" style="width:100%;height:100%;object-fit:cover;border-radius:10px;" onerror="this.style.display='none'" />` : '';
        topCard.innerHTML = `
          ${backImg}
          <div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;">
            <span style="background:#D12128;color:white;padding:8px 16px;border-radius:20px;font-size:14px;font-weight:500;">
              <i class="f7-icons" style="font-size:14px;">arrow_2_circlepath</i> Tap
            </span>
          </div>
        `;
      }
      
      // Add click handler
      topCard.addEventListener('click', () => handleCardClick(pile));
      
      stackEl.appendChild(topCard);
    }
  }
  
  // Handle card click
  function handleCardClick(pile) {
    const deck = pile === 'black' ? state.blackDeck : state.whiteDeck;
    const currentCard = pile === 'black' ? state.currentBlack : state.currentWhite;
    
    if (!currentCard && deck && deck.length > 0) {
      // Draw a new card (it will be automatically flipped/revealed)
      drawCard(pile);
    } else if (currentCard) {
      // Toggle flip state
      flipCard(pile);
    }
    
    updateUI();
  }
  
  // Update all UI elements
  function updateUI() {
    const blackDeckCount = state.blackDeck ? state.blackDeck.length : 0;
    const whiteDeckCount = state.whiteDeck ? state.whiteDeck.length : 0;
    
    console.log('[Game] updateUI - black:', blackDeckCount, 'white:', whiteDeckCount);
    
    // Render both stacks
    renderStack('black');
    renderStack('white');
    
    // Update counts
    const blackCountEl = document.getElementById('black-count');
    const whiteCountEl = document.getElementById('white-count');
    
    if (blackCountEl) blackCountEl.textContent = `${blackDeckCount} cards left`;
    if (whiteCountEl) whiteCountEl.textContent = `${whiteDeckCount} cards left`;
    
    // Update pile visibility
    updatePileVisibility();
  }
  
  function checkOrientation() {
    const isLandscape = window.innerWidth > window.innerHeight;
    const rotateScreen = document.getElementById('rotate-screen');
    const gameContent = document.getElementById('game-content');
    
    if (rotateScreen && gameContent) {
      rotateScreen.style.display = isLandscape ? 'none' : 'flex';
      gameContent.style.display = isLandscape ? 'flex' : 'none';
    }
  }
  
  function updateTimerDisplay() {
    const timerEl = document.getElementById('timer-display');
    if (!timerEl) return;
    
    const { timerState, timerSeconds } = state;
    
    timerEl.className = `timer-display ${timerState}`;
    
    switch (timerState) {
      case 'idle':
        timerEl.textContent = 'Tap on the cards to flip them and start your turn';
        break;
      case 'countdown':
        timerEl.textContent = `Ready? Tap to begin sharing (${timerSeconds}s)`;
        break;
      case 'waiting':
        timerEl.textContent = 'Ready when you are — tap to start sharing';
        break;
      case 'countup':
        const mins = Math.floor(timerSeconds / 60);
        let msg = "Tap when you're done sharing";
        if (mins >= 3) msg = "Tap when done. 3 minutes — wrapping up?";
        else if (mins >= 2) msg = "Tap when done. 2 minutes — you're in the flow.";
        else if (mins >= 1) msg = "Tap when done. 1 minute — keep sharing.";
        timerEl.textContent = msg;
        break;
      case 'finished':
        const finMins = Math.floor(timerSeconds / 60);
        const finSecs = timerSeconds % 60;
        let timeStr = finSecs + 's';
        if (finMins > 0) timeStr = `${finMins}m ${finSecs}s`;
        timerEl.textContent = `Done (${timeStr}) — tap to reset for next turn`;
        break;
    }
  }
  
  // Event listeners
  window.addEventListener('resize', checkOrientation);
  window.addEventListener('orientationchange', checkOrientation);
  document.addEventListener('timer-update', updateTimerDisplay);
  
  // Listen for cards-loaded event (dispatched when async load completes)
  document.addEventListener('cards-loaded', (e) => {
    console.log('[Game] Cards loaded event received:', e.detail);
    updateUI();
  });
  
  // Timer click
  document.getElementById('timer-display')?.addEventListener('click', () => {
    const { timerState } = state;
    if (timerState === 'countdown' || timerState === 'waiting') {
      startSharing();
    } else if (timerState === 'countup') {
      finishSharing();
    } else if (timerState === 'finished') {
      // Reset round - current cards disappear, ready for next turn
      resetRound();
      updateUI();
    }
    updateTimerDisplay();
  });
  
  // Reset button
  document.getElementById('reset-btn')?.addEventListener('click', () => {
    resetRound();
    updateUI();
    updateTimerDisplay();
  });
  
  // Exit button
  document.getElementById('exit-btn')?.addEventListener('click', () => {
    endGame();
    window.f7App.views.main.router.navigate('/experience/');
  });
  
  // Initial setup
  console.log('[Game] Page init - state:', {
    blackDeck: state.blackDeck?.length || 0,
    whiteDeck: state.whiteDeck?.length || 0,
    gameStarted: state.gameStarted,
    blackPileImage: state.blackPileImage,
    whitePileImage: state.whitePileImage
  });
  
  checkOrientation();
  updateUI();
  updateTimerDisplay();
})();
</script>
