<div class="page" data-name="experience">
  <div class="navbar">
    <div class="navbar-bg"></div>
    <div class="navbar-inner">
      <div class="title">Select Deck</div>
    </div>
  </div>
  
  <div class="toolbar tabbar tabbar-labels toolbar-bottom">
    <div class="toolbar-inner">
      <a href="/" class="tab-link">
        <i class="f7-icons">house_fill</i>
        <span class="tabbar-label">Home</span>
      </a>
      <a href="/experience/" class="tab-link tab-link-active">
        <i class="f7-icons">gamecontroller_fill</i>
        <span class="tabbar-label">Experience</span>
      </a>
      <a href="/store/" class="tab-link">
        <i class="f7-icons">bag_fill</i>
        <span class="tabbar-label">Store</span>
      </a>
      <a href="/profile/" class="tab-link">
        <i class="f7-icons">person_fill</i>
        <span class="tabbar-label">Profile</span>
      </a>
    </div>
  </div>
  
  <div class="page-content">
    <div class="block-title">Choose Your Decks</div>
    <div class="block">
      <p style="color: #8E8E93;">Select one or more decks to play with. Tap to select, then press Play.</p>
    </div>
    
    <div id="deck-scroll" class="deck-scroll">
      <!-- Loading indicator -->
      <div id="loading-indicator" style="padding: 40px; text-align: center; color: #8E8E93;">
        Loading decks...
      </div>
    </div>
    
    <div class="block" style="margin-top: 24px;">
      <button id="play-btn" class="button button-large button-fill disabled" style="max-width: 280px; margin: 0 auto;">
        <i class="f7-icons">play_fill</i>
        <span style="margin-left: 8px;">Play</span>
      </button>
    </div>
    
    <div class="block" style="padding-bottom: 100px;"></div>
  </div>
</div>

<script>
(function() {
  const state = window.appState;
  const { startGame } = window.appFunctions;
  let selectedBoxIds = [];
  
  function renderDecks() {
    const container = document.getElementById('deck-scroll');
    if (!container) return;
    
    const boxes = state.boxes || [];
    console.log('Rendering decks, boxes:', boxes.length);
    
    if (boxes.length === 0) {
      container.innerHTML = `
        <div style="padding: 40px; text-align: center; color: #8E8E93;">
          No decks available. Check your connection to the local API.
        </div>
      `;
      return;
    }
    
    // Filter to show sample boxes and boxes user has access to
    const availableBoxes = boxes.filter(b => b.is_sample || b.hasAccess || state.hasAllAccess);
    const lockedBoxes = boxes.filter(b => !b.is_sample && !b.hasAccess && !state.hasAllAccess);
    
    const renderTile = (box, locked = false) => {
      const heroImage = box.path ? `/collections/${box.path}/hero.jpg` : '/assets/logo-asweallare.png';
      
      return `
        <div class="deck-tile ${locked ? 'locked' : ''}" 
             data-box-id="${box.id}" 
             data-locked="${locked}" 
             data-sample="${box.is_sample}"
             style="border: 2px solid ${locked ? '#ddd' : 'transparent'};">
          <img src="${heroImage}" alt="${box.name}" 
               onerror="this.src='/assets/logo-asweallare.png'" 
               style="opacity: ${locked ? '0.6' : '1'};" />
          ${box.is_sample ? '<span class="sample-badge">SAMPLE</span>' : ''}
          ${locked ? `
            <div class="lock-overlay">
              <i class="f7-icons" style="color: white; font-size: 32px;">lock_fill</i>
            </div>
          ` : ''}
          <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 12px; background: linear-gradient(transparent, rgba(0,0,0,0.7));">
            <p style="color: white; font-weight: 600; font-size: 14px; margin: 0;">${box.name}</p>
            ${box.tagline ? `<p style="color: rgba(255,255,255,0.7); font-size: 11px; margin: 4px 0 0 0;">${box.tagline}</p>` : ''}
          </div>
        </div>
      `;
    };
    
    // Render available first, then locked
    const allTiles = [
      ...availableBoxes.map(b => renderTile(b, false)),
      ...lockedBoxes.map(b => renderTile(b, true))
    ];
    
    container.innerHTML = allTiles.join('');
    
    // Add click handlers
    container.querySelectorAll('.deck-tile').forEach(tile => {
      tile.addEventListener('click', () => {
        const boxId = tile.dataset.boxId;
        const isLocked = tile.dataset.locked === 'true';
        const isSample = tile.dataset.sample === 'true';
        
        if (isLocked) {
          window.f7App.dialog.alert('This deck is locked. Purchase it in the Store to unlock.', 'Locked');
          return;
        }
        
        if (selectedBoxIds.includes(boxId)) {
          selectedBoxIds = selectedBoxIds.filter(id => id !== boxId);
          tile.style.borderColor = 'transparent';
          tile.style.transform = 'scale(1)';
        } else {
          selectedBoxIds.push(boxId);
          tile.style.borderColor = '#007AFF';
          tile.style.transform = 'scale(0.95)';
        }
        
        const playBtn = document.getElementById('play-btn');
        if (playBtn) {
          if (selectedBoxIds.length > 0) {
            playBtn.classList.remove('disabled');
          } else {
            playBtn.classList.add('disabled');
          }
        }
        
        console.log('Selected boxes:', selectedBoxIds);
      });
    });
  }
  
  // Play button handler
  const playBtn = document.getElementById('play-btn');
  if (playBtn) {
    playBtn.addEventListener('click', () => {
      if (selectedBoxIds.length > 0) {
        console.log('Starting game with boxes:', selectedBoxIds);
        startGame(selectedBoxIds);
        window.f7App.views.main.router.navigate('/game/');
      }
    });
  }
  
  // Try to render immediately if data is already loaded
  if (state.boxes && state.boxes.length > 0) {
    console.log('Data already loaded, rendering immediately');
    renderDecks();
  } else {
    console.log('Waiting for data to load...');
    // Poll for data (since it might still be loading)
    let attempts = 0;
    const checkData = setInterval(() => {
      attempts++;
      if (state.boxes && state.boxes.length > 0) {
        clearInterval(checkData);
        renderDecks();
      } else if (attempts > 20) {
        clearInterval(checkData);
        renderDecks(); // Render even if empty to show message
      }
    }, 250);
  }
})();
</script>
